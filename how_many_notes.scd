// Code for "How Many Notes?!", published 19 February 2019
// at The Humming of the Strings.

// This code generates a sequence of perfect fifths, normalized
// to fit within a single octave and outputs this list as ~pyArray.
// It also identifies natural cutoff
// points in three ways. First, it identifies when the sequence has
// reached a note that is closer to the starting note than any other
// note thus far. These values are recorded in ~cutoffs. Second,
// it identifies when the sequence has reached a note that more
// closely approaches the starting note from above than any
// other note thus far. These values are recorded in ~lowCutoffs.
// Third, it identifies when the sequence has reached a note that
// more closely approaches the starting note from below than any
// other note thus far. These values are recorded in ~highCutoffs.

// As written, the code will generate 100000 notes. You can modify the
// code to generate a smaller number of notes to use for musical examples
// by changing the "100000" before ".do" to one fewer than the number
// of notes you want in your scale. For example, for a chromatic scale,
// you would change "100000" to "11".

(
~pyArray = [1];
~lowCutoffs = [];
~highCutoffs = [];
~cutoffs = [];
~lowMin = 2;
~highMin = 2;
~min = 2;
100000.do{
	arg i;
	var last, new, ratio;
	last = ~pyArray.last;
	new = last * 3/2;
	if (new > 2) {
		new = new/2;
		ratio = new;
		if (ratio < ~lowMin) {
			~lowMin = ratio;
			~lowCutoffs = ~lowCutoffs ++ [i+1]
		}{};
		if (ratio < ~min) {
			~min = ratio;
			~cutoffs = ~cutoffs ++ [i+1]
		}{};
	} {
			ratio = 2/new;
		if (ratio < ~highMin) {
			~highMin = ratio;
			~highCutoffs = ~highCutoffs ++ [i+1]
		}{};
		if (ratio < ~min) {
			~min = ratio;
			~cutoffs = ~cutoffs ++ [i+1]
		}{};
		};
	~pyArray = ~pyArray ++ [new];
};
)

// Sort the scale generated by the previous code.

~pyArray = ~pyArray.sort;

// Display the cutoff lists generated by the previous code.

~lowCutoffs;
~highCutoffs;
~cutoffs;

// This code creates the basic synth we will use.
// It plays a sawtooth wave multiplied by a percussive
// envelope. The attack and release time of the envelope
// can be set when calling the synth.

(
SynthDef.new(\tone, {
	arg freq = 330, index = 0, mul = 1, atk = 0.01, rel=0.5, out=0;
	var sig, env;
	sig = Saw.ar(freq);
	env = EnvGen.kr(Env.perc(atk, rel), doneAction: 2);
	sig = sig * env * mul;
	sig = LPF.ar(sig, freq*4);
	Out.ar(out,sig);
}).add;
)

// This code will play an interval from ~pyArray. To adjust the
// interval, just change the numbers inside the square brackets
// after "~pyArray".

(
Synth.new(\tone, [\freq, 330 * ~pyArray[0], \rel, 3]);
Synth.new(\tone, [\freq, 330 * ~pyArray[2], \rel, 3]);
)

// This code generates a pattern to play the scale given by ~pyArray.
// It plays up and then down one octave of the scale.
// The time between successive notes can be adjusted by changing
// the "\dur" value. The volume of each note can be adjusted by changing
// the "\mul" value. The amount of time each note is held can be adjusted
// by changing the "\rel" value.

(
~scale = Pdef(
	\scale,
	Pbind(
		\instrument, \tone,
		\freq, 330 * Pseq(~pyArray ++ [2] ++ ~pyArray.reverse, 1),
		\dur, 0.2,
		\mul, 0.6,
		\rel, 0.6
	);
);
)

~scale.play;
~scale.stop;

s.record;
s.stopRecording;
